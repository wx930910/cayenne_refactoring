// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to you under the Apache License, Version
// 2.0 (the "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0 Unless required by
// applicable law or agreed to in writing, software distributed under the
// License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for
// the specific language governing permissions and limitations under the
// License.
[[select]]
==== ObjectSelect

NOTE: ObjectSelect supersedes older SelectQuery. SelectQuery is still available and supported, but will be deprecated
in the future.

===== Selecting objects

`ObjectSelect` is the most commonly used query in Cayenne applications. This may be the only query you will ever need.
It returns a list of persistent objects (or data rows) of a certain type specified in the query:

[source, java]
----
List<Artist> objects = ObjectSelect.query(Artist.class).select(context);
----

This returned all rows in the _ARTIST_ table. If the logs were turned on, you might see the following SQL printed:

[source]
----
INFO: SELECT t0.DATE_OF_BIRTH, t0.NAME, t0.ID FROM ARTIST t0
INFO: === returned 5 row. - took 5 ms.
----

This SQL was generated by Cayenne from the `ObjectSelect` above.
`ObjectSelect` can have a qualifier to select only the data matching specific criteria.
Qualifier is simply an Expression (Expressions where discussed in the previous chapter),
appended to the query using "where" method. If you only want artists whose name begins with 'Pablo',
you might use the following qualifier expression:

[source, java]
----
List<Artist> objects = ObjectSelect.query(Artist.class)
    .where(Artist.NAME.like("Pablo%"))
    .select(context);
----

The SQL will look different this time:

[source]
----
INFO: SELECT t0.DATE_OF_BIRTH, t0.NAME, t0.ID FROM ARTIST t0 WHERE t0.NAME LIKE ?
[bind: 1->NAME:'Pablo%']
INFO: === returned 1 row. - took 6 ms.
----

`ObjectSelect` allows to assemble qualifier from parts, using "and" and "or" method to chain then together:

[source, java]
----
List<Artist> objects = ObjectSelect.query(Artist.class)
    .where(Artist.NAME.like("A%"))
    .and(Artist.DATE_OF_BIRTH.gt(someDate)
    .select(context);
----

To order the results of `ObjectSelect`, one or more orderings can be applied:

[source, java]
----
List<Artist> objects = ObjectSelect.query(Artist.class)
    .orderBy(Artist.DATE_OF_BIRTH.desc())
    .orderBy(Artist.NAME.asc())
    .select(context);
----

There's a number of other useful methods in `ObjectSelect` that define what to select
and how to optimize database interaction (prefetching, caching, fetch offset and limit, pagination, etc.).
Some of them are discussed in separate chapters on caching and performance optimization.
Others are fairly self-explanatory. Please check the API docs for the full extent of the `ObjectSelect` features.

===== Selecting individual columns

`ObjectSelect` query can be used to fetch individual properties of objects via type-safe API:

[source, java]
----
List<String> names = ObjectSelect
    .columnQuery(Artist.class, Artist.ARTIST_NAME)
    .select(context);
----

And here is an example of selecting several properties. The result is a list of `Object[]`:

[source, java]
----
List<Object[]> nameAndDate = ObjectSelect
    .columnQuery(Artist.class, Artist.ARTIST_NAME, Artist.DATE_OF_BIRTH)
    .select(context);
----

===== Selecting using aggregate functions

ObjectSelect query supports usage of aggregate functions.
Most common variant of aggregation is selecting count of records, this can be done really easy:

[source, java]
----
long count = ObjectSelect.query(Artist.class).selectCount(context);
----

But you can use aggregates in more cases, even combine selecting individual properties and aggregates:

[source, java]
----
// this is artificial property signaling that we want to get full object
Property<Artist> artistProperty = Property.createSelf(Artist.class);

List<Object[]> artistAndPaintingCount = ObjectSelect.columnQuery(Artist.class, artistProperty, Artist.PAINTING_ARRAY.count())
    .where(Artist.ARTIST_NAME.like("a%"))
    .having(Artist.PAINTING_ARRAY.count().lt(5L))
    .orderBy(Artist.PAINTING_ARRAY.count().desc(), Artist.ARTIST_NAME.asc())
    .select(context);

for(Object[] next : artistAndPaintingCount) {
    Artist artist = (Artist)next[0];
    long paintings = (Long)next[1];
    System.out.println(artist.getArtistName() + " have " + paintings + " paintings");
}
----

Here is generated `SQL` for this query:

[source, SQL]
----
SELECT DISTINCT t0.ARTIST_NAME, t0.DATE_OF_BIRTH, t0.ARTIST_ID, COUNT(t1.PAINTING_ID)
FROM ARTIST t0 JOIN PAINTING t1 ON (t0.ARTIST_ID = t1.ARTIST_ID)
WHERE t0.ARTIST_NAME LIKE ?
GROUP BY t0.ARTIST_NAME, t0.ARTIST_ID, t0.DATE_OF_BIRTH
HAVING COUNT(t1.PAINTING_ID) < ?
ORDER BY COUNT(t1.PAINTING_ID) DESC, t0.ARTIST_NAME
----
